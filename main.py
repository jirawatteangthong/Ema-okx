import ccxt
import time
import requests
from datetime import datetime, timedelta
import logging
import threading
import json
import os
import calendar
import sys
import math

# ==============================================================================
# 1. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (CONFIGURATION)
# ==============================================================================

# --- API Keys & Credentials (‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å Environment Variables ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢) ---
# ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô Environment Variables: OKX_API_KEY, OKX_SECRET, OKX_PASSWORD
API_KEY = os.getenv('OKX_API_KEY', 'YOUR_OKX_API_KEY_HERE_FOR_LOCAL_TESTING')
SECRET = os.getenv('OKX_SECRET', 'YOUR_OKX_SECRET_HERE_FOR_LOCAL_TESTING')
PASSWORD = os.getenv('OKX_PASSWORD', 'YOUR_OKX_PASSWORD_HERE_FOR_LOCAL_TESTING') # Passphrase for OKX

# --- Trade Parameters ---
SYMBOL = 'BTC-USDT-SWAP' # <--- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå OKX Perpetual Swap
TIMEFRAME = '3m' # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô 3 ‡∏ô‡∏≤‡∏ó‡∏µ
LEVERAGE = 35    # <--- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Leverage ‡πÄ‡∏õ‡πá‡∏ô 35x ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
TP_DISTANCE_POINTS = 250  # ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏•‡∏≠‡∏á 50 ‡∏à‡∏∏‡∏î
SL_DISTANCE_POINTS = 400  # ‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏•‡∏≠‡∏á 200 ‡∏à‡∏∏‡∏î (‡∏´‡∏£‡∏∑‡∏≠‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤)
BE_PROFIT_TRIGGER_POINTS = 200  # ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô SL ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡πÑ‡∏£ 40 ‡∏à‡∏∏‡∏î (‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ TP)
BE_SL_BUFFER_POINTS = 50   # ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô SL ‡πÑ‡∏õ‡∏ï‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà +10 ‡∏à‡∏∏‡∏î (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏ô SL ‡∏Å‡πá‡∏¢‡∏±‡∏á‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢)
CROSS_THRESHOLD_POINTS = 1 

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
# MARGIN_BUFFER_USDT = 25 # <--- ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
TARGET_POSITION_SIZE_FACTOR = 0.7  # <--- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (0.7 = 70%)
MARGIN_BUFFER_PERCENTAGE = 0.05 # <--- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ: 5% ‡∏Ç‡∏≠‡∏á‡∏¢‡∏≠‡∏î Available USDT ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô Margin Buffer
MIN_MARGIN_BUFFER_USDT = 5.0 # <--- ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ö‡∏±‡∏ü‡πÄ‡∏ü‡∏≠‡∏£‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÄ‡∏õ‡πá‡∏ô USDT (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏∏‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å)

# ‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå (‡πÉ‡∏ä‡πâ‡πÉ‡∏ô confirm_position_entry)
CONFIRMATION_RETRIES = 15  
CONFIRMATION_SLEEP = 5  

# --- Telegram Notification Settings ---
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN', 'YOUR_TELEGRAM_TOKEN_HERE_FOR_LOCAL_TESTING')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', 'YOUR_CHAT_ID_HERE_FOR_LOCAL_TESTING')

# --- Files & Paths ---
STATS_FILE = 'trading_stats.json' # ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô '/data/trading_stats.json' ‡∏´‡∏≤‡∏Å‡πÉ‡∏ä‡πâ Railway Volume

# --- Bot Timing ---
MAIN_LOOP_SLEEP_SECONDS = 180 
ERROR_RETRY_SLEEP_SECONDS = 60
MONTHLY_REPORT_DAY = 20
MONTHLY_REPORT_HOUR = 0
MONTHLY_REPORT_MINUTE = 5

# --- Tolerance ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå ---
TP_SL_BE_PRICE_TOLERANCE_PERCENT = 0.005 

# ==============================================================================
# 2. ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Logging
# ==============================================================================
logging.basicConfig(
    level=logging.DEBUG, # <--- ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ INFO ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥, ‡∏´‡∏≤‡∏Å‡∏ï‡∏¥‡∏î‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Ñ‡πà‡∏≠‡∏¢‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô DEBUG
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
for handler in logging.root.handlers:
    if hasattr(handler, 'flush'):
        handler.flush = lambda: sys.stdout.flush() if isinstance(handler, logging.StreamHandler) else handler.stream.flush()

logger = logging.getLogger(__name__)


# ==============================================================================
# 3. ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î (GLOBAL TRADE STATE VARIABLES)
# ==============================================================================
current_position_details = None 
entry_price = None
sl_moved = False
portfolio_balance = 0.0
last_monthly_report_date = None
initial_balance = 0.0
current_position_size = 0.0 # ‡∏Ç‡∏ô‡∏≤‡∏î‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢ Contracts
last_ema_position_status = None 

# ==============================================================================
# 4. ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ (STATISTICS DATA STRUCTURE)
# ==============================================================================
monthly_stats = {
    'month_year': None,
    'tp_count': 0,
    'sl_count': 0,
    'total_pnl': 0.0,
    'trades': [],
    'last_report_month_year': None,
    'last_ema_cross_signal': None, 
    'last_ema_position_status': None 
}

# ==============================================================================
# 5. ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Exchange (CCXT EXCHANGE SETUP)
# ==============================================================================
exchange = None 
market_info = None 

def setup_exchange():
    global exchange, market_info
    try:
        if not all([API_KEY, SECRET, PASSWORD]) or \
           API_KEY == 'YOUR_OKX_API_KEY_HERE_FOR_LOCAL_TESTING': 
            raise ValueError("API_KEY, SECRET, ‡∏´‡∏£‡∏∑‡∏≠ PASSWORD (Passphrase) ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô Environment Variables.")

        exchange = ccxt.okx({ 
            'apiKey': API_KEY,
            'secret': SECRET,
            'password': PASSWORD, 
            'enableRateLimit': True,
            'options': {
                'defaultType': 'swap', 
                'warnOnFetchOHLCVLimitArgument': False,
                'adjustForTimeDifference': True,
            },
            'verbose': False, 
            'timeout': 30000,
        })
        exchange.set_sandbox_mode(False) 
        
        exchange.load_markets()
        logger.info("‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö OKX Exchange ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏•‡∏î Markets ‡πÅ‡∏•‡πâ‡∏ß.")
        
        market_info = exchange.market(SYMBOL)
        if not market_info:
            raise ValueError(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏•‡∏≤‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {SYMBOL}")
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö limits ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏°‡∏µ
        if 'limits' not in market_info:
            market_info['limits'] = {}
        if 'amount' not in market_info['limits']:
            market_info['limits']['amount'] = {}
        if 'cost' not in market_info['limits']:
            market_info['limits']['cost'] = {}

        # ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ step, min, max ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö amount (contracts)
        amount_step = market_info['limits']['amount'].get('step')
        market_info['limits']['amount']['step'] = float(amount_step) if amount_step is not None else 1.0 # Default to 1.0 contract step for OKX
        
        amount_min = market_info['limits']['amount'].get('min')
        market_info['limits']['amount']['min'] = float(amount_min) if amount_min is not None else 1.0 # Default to 1.0 minimum contract
        
        amount_max = market_info['limits']['amount'].get('max')
        market_info['limits']['amount']['max'] = float(amount_max) if amount_max is not None else sys.float_info.max 

        # ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ min, max ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö cost (notional value)
        cost_min = market_info['limits']['cost'].get('min')
        market_info['limits']['cost']['min'] = float(cost_min) if cost_min is not None else 11.8 # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï default ‡∏ï‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        
        cost_max = market_info['limits']['cost'].get('max')
        market_info['limits']['cost']['max'] = float(cost_max) if cost_max is not None else sys.float_info.max 

        logger.debug(f"DEBUG: Market info limits for {SYMBOL}:")
        logger.debug(f"  Amount: step={market_info['limits']['amount']['step']}, min={market_info['limits']['amount']['min']}, max={market_info['limits']['amount']['max']}")
        logger.debug(f"  Cost: min={market_info['limits']['cost']['min']}, max={market_info['limits']['cost']['max']}")
        # --- IMPORTANT: market_info.get('contractSize') might be incorrect ---
        # We will use a hardcoded value in calculate_order_details for BTC-USDT-SWAP
        logger.debug(f"  Contract Size (from market_info, for reference only): {market_info.get('contractSize', 'N/A')}") 
        # ‡πÄ‡∏û‡∏¥‡πà‡∏° logging ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö full market_info
        logger.debug(f"DEBUG: Full market_info for {SYMBOL}: {json.dumps(market_info, indent=2)}")

        try:
            result = exchange.set_leverage(LEVERAGE, SYMBOL, params={'mgnMode': 'cross'}) 
            logger.info(f"‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Leverage ‡πÄ‡∏õ‡πá‡∏ô {LEVERAGE}x ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {SYMBOL}: {result}")
        except ccxt.ExchangeError as e:
            if "leverage is not valid" in str(e) or "not valid for this symbol" in str(e):
                logger.critical(f"‚ùå Error: Leverage {LEVERAGE}x ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {SYMBOL} ‡∏ö‡∏ô OKX. ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Max Allowed Leverage.")
            else:
                logger.critical(f"‚ùå Error ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Leverage: {e}", exc_info=True)
            exit()
        
    except ValueError as ve:
        logger.critical(f"‚ùå Configuration Error: {ve}", exc_info=True)
        exit()
    except Exception as e:
        logger.critical(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Exchange ‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏î‡πâ: {e}", exc_info=True)
        exit()

# ==============================================================================
# 6. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ (STATISTICS MANAGEMENT FUNCTIONS)
# ==============================================================================

def save_monthly_stats():
    global monthly_stats, last_ema_position_status
    try:
        monthly_stats['last_ema_position_status'] = last_ema_position_status
        with open(os.path.join(os.getcwd(), STATS_FILE), 'w') as f:
            json.dump(monthly_stats, f, indent=4)
        logger.debug(f"üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå {STATS_FILE} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
    except Exception as e:
        logger.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏¥‡∏ï‡∏¥‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥: {e}")

def reset_monthly_stats():
    global monthly_stats, last_ema_position_status
    monthly_stats['month_year'] = datetime.now().strftime('%Y-%m')
    monthly_stats['tp_count'] = 0
    monthly_stats['sl_count'] = 0
    monthly_stats['total_pnl'] = 0.0
    monthly_stats['trades'] = []
    last_ema_position_status = None 
    save_monthly_stats() 
    logger.info(f"üîÑ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô {monthly_stats['month_year']}")

def load_monthly_stats():
    global monthly_stats, last_monthly_report_date, last_ema_position_status
    try:
        stats_file_path = os.path.join(os.getcwd(), STATS_FILE)
        if os.path.exists(stats_file_path):
            with open(stats_file_path, 'r') as f:
                loaded_stats = json.load(f)

                monthly_stats['month_year'] = loaded_stats.get('month_year', None)
                monthly_stats['tp_count'] = loaded_stats.get('tp_count', 0)
                monthly_stats['sl_count'] = loaded_stats.get('sl_count', 0)
                monthly_stats['total_pnl'] = loaded_stats.get('total_pnl', 0.0)
                monthly_stats['trades'] = loaded_stats.get('trades', [])
                monthly_stats['last_report_month_year'] = loaded_stats.get('last_report_month_year', None)
                monthly_stats['last_ema_cross_signal'] = loaded_stats.get('last_ema_cross_signal', None)
                last_ema_position_status = loaded_stats.get('last_ema_position_status', None)

            logger.info(f"üíæ ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå {STATS_FILE} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")

            if monthly_stats['last_report_month_year']:
                try:
                    year, month = map(int, monthly_stats['last_report_month_year'].split('-'))
                    last_monthly_report_date = datetime(year, month, 1).date()
                except ValueError:
                    logger.warning("‚ö†Ô∏è ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà last_report_report_month_year ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á. ‡∏à‡∏∞‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô.")
                    last_monthly_report_date = None
            else:
                last_monthly_report_date = None

            current_month_year_str = datetime.now().strftime('%Y-%m')
            if monthly_stats['month_year'] != current_month_year_str:
                logger.info(f"üÜï ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô {monthly_stats['month_year']} ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ {current_month_year_str}. ‡∏à‡∏∞‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÉ‡∏´‡∏°‡πà.")
                reset_monthly_stats()

        else:
            logger.info(f"üÜï ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ {STATS_FILE} ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà")
            reset_monthly_stats()

    except Exception as e:
        logger.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥: {e}", exc_info=True)
        if not os.access(os.path.dirname(stats_file_path) or '.', os.W_OK):
             logger.critical(f"‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÑ‡∏î‡πÄ‡∏£‡∏Å‡∏ó‡∏≠‡∏£‡∏µ: {os.path.dirname(stats_file_path) or '.'}. ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô STATS_FILE.")

        monthly_stats = {
            'month_year': None, 'tp_count': 0, 'sl_count': 0, 'total_pnl': 0.0, 'trades': [],
            'last_report_month_year': None, 'last_ema_cross_signal': None, 'last_ema_position_status': None
        }
        last_monthly_report_date = None
        last_ema_position_status = None
        reset_monthly_stats()

def add_trade_result(reason: str, pnl: float):
    global monthly_stats
    current_month_year_str = datetime.now().strftime('%Y-%m')

    if monthly_stats['month_year'] != current_month_year_str:
        logger.info(f"üÜï ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÉ‡∏ô add_trade_result: {monthly_stats['month_year']} -> {current_month_year_str}. ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡πÄ‡∏î‡∏∑‡∏≠‡∏ô.")
        reset_monthly_stats()

    if reason.upper() == 'TP':
        monthly_stats['tp_count'] += 1
    elif reason.upper() == 'SL' or reason.upper() == 'SL (‡∏Å‡∏±‡∏ô‡∏ó‡∏∏‡∏ô)':
        monthly_stats['sl_count'] += 1

    monthly_stats['total_pnl'] += pnl

    monthly_stats['trades'].append({
        'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'reason': reason,
        'pnl': pnl
    })
    save_monthly_stats()

# ==============================================================================
# 7. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô Telegram (TELEGRAM NOTIFICATION FUNCTIONS)
# ==============================================================================
def send_telegram(msg: str):
    if not TELEGRAM_TOKEN or TELEGRAM_TOKEN == 'YOUR_TELEGRAM_TOKEN_HERE_FOR_LOCAL_TESTING' or \
       not TELEGRAM_CHAT_ID or TELEGRAM_CHAT_ID == 'YOUR_CHAT_ID_HERE_FOR_LOCAL_TESTING':
        logger.warning("‚ö†Ô∏è TELEGRAM_TOKEN ‡∏´‡∏£‡∏∑‡∏≠ TELEGRAM_CHAT_ID ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤. ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Telegram ‡πÑ‡∏î‡πâ.")
        return

    try:
        url = f'https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage'
        params = {'chat_id': TELEGRAM_CHAT_ID, 'text': msg, 'parse_mode': 'HTML'}
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status() 
        logger.info(f"‚úâÔ∏è Telegram: {msg.splitlines()[0]}...")
    except requests.exceptions.Timeout:
        logger.error("‚õîÔ∏è Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Telegram ‡πÑ‡∏î‡πâ (Timeout)")
    except requests.exceptions.HTTPError as e:
        telegram_error_msg = e.response.json().get('description', e.response.text)
        logger.error(f"‚õîÔ∏è Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Telegram ‡πÑ‡∏î‡πâ (HTTP Error) - ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {telegram_error_msg}")
    except requests.exceptions.RequestException as e:
        logger.error(f"‚õîÔ∏è Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Telegram ‡πÑ‡∏î‡πâ (Request Error) - {e}")
    except Exception as e:
        logger.error(f"‚ùå Unexpected Telegram error: {e}")

# ==============================================================================
# 8. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Exchange (EXCHANGE DATA RETRIEVAL FUNCTIONS)
# ==============================================================================

def get_portfolio_balance() -> float:
    """‡∏î‡∏∂‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ USDT ‡πÉ‡∏ô‡∏û‡∏≠‡∏£‡πå‡∏ï‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö OKX (Trading Account / Total Equity)."""
    global portfolio_balance
    retries = 3
    for i in range(retries):
        try:
            logger.debug(f"üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ (Attempt {i+1}/{retries})...")
            balance_data = exchange.fetch_balance(params={'type': 'trade'}) 
            time.sleep(1) 
            
            usdt_balance = 0.0
            if 'USDT' in balance_data and 'free' in balance_data['USDT']:
                usdt_balance = float(balance_data['USDT']['free'])
            else: 
                okx_balance_info = balance_data.get('info', {}).get('data', [])
                if okx_balance_info:
                    for account in okx_balance_info:
                        if account.get('ccy') == 'USDT' and account.get('type') == 'TRADE':
                            usdt_balance = float(account.get('availBal', 0.0)) 
                            break
            
            if usdt_balance > 0:
                portfolio_balance = usdt_balance
                logger.info(f"üí∞ ‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ USDT (OKX): {portfolio_balance:,.2f}")
                return portfolio_balance
            else:
                 logger.warning("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ USDT ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ OKX (availBal).")
                 return 0.0

        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"‚ö†Ô∏è Error fetching balance (Attempt {i+1}/{retries}): {e}. Retrying in 15 seconds...")
            if i == retries - 1:
                send_telegram(f"‚õîÔ∏è API Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏î‡πâ (Attempt {i+1}/{retries})\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {e}")
            time.sleep(15)
        except Exception as e:
            logger.error(f"‚ùå Unexpected error in get_portfolio_balance: {e}", exc_info=True)
            send_telegram(f"‚õîÔ∏è Unexpected Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏î‡πâ\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {e}")
            return 0.0
    logger.error(f"‚ùå Failed to fetch balance after {retries} attempts.")
    send_telegram(f"‚õîÔ∏è API Error: ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å {retries} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á.")
    return 0.0

def get_current_position() -> dict | None:
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô BTC/USDT ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö OKX.
    ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Hedge Mode ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ 'pos' field.
    """
    retries = 3
    for i in range(retries):
        try:
            logger.debug(f"üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (Attempt {i+1}/{retries})...")
            positions = exchange.fetch_positions([SYMBOL]) 
            logger.debug(f"DEBUG: Raw positions fetched: {positions}") # <--- Keep this for full raw data inspection
            time.sleep(1) 
            
            active_positions = [
                pos for pos in positions
                if pos.get('info', {}).get('instId') == SYMBOL and float(pos.get('info', {}).get('pos', '0')) != 0
            ]
            
            if not active_positions:
                logger.debug(f"‚ÑπÔ∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {SYMBOL}")
                return None

            for pos in active_positions:
                pos_info = pos.get('info', {})
                pos_amount_str = pos_info.get('pos') 
                
                # *** IMPORTANT: Use pos['contracts'] or pos['amount'] if available and correctly normalized by CCXT ***
                # If pos_info.get('pos') returns a value like "1" but means "1 contract"
                # and CCXT's 'amount' or 'contracts' field is also 1, then use it.
                # If 'pos' field from OKX API sometimes returns a BTC value, not contract count,
                # then you would need to convert it using the correct contract_size (0.0001 BTC/contract).
                # For now, let's assume 'pos' here is contract count, based on the previous log showing 'Size=1.0 Contracts'.
                pos_amount = abs(float(pos_amount_str)) 

                entry_price_okx = float(pos_info.get('avgPx', 0.0))
                unrealized_pnl_okx = float(pos_info.get('upl', 0.0))
                
                side = pos_info.get('posSide', '').lower()

                if side != 'net' and pos_amount > 0:
                    logger.debug(f"‚úÖ ‡∏û‡∏ö‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {SYMBOL}: Side={side}, Size={pos_amount}, Entry={entry_price_okx}")
                    return {
                        'side': side,
                        'size': pos_amount, # This is the contract count
                        'entry_price': entry_price_okx,
                        'unrealized_pnl': unrealized_pnl_okx,
                        'pos_id': pos.get('id', 'N/A') 
                    }
            
            logger.debug(f"‚ö†Ô∏è ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {SYMBOL} ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç active/hedge mode.")
            return None 

        except (ccxt.NetworkError, ccxt.ExchangeError) as e:
            logger.warning(f"‚ö†Ô∏è Error fetching positions (Attempt {i+1}/{retries}): {e}. Retrying in 15 seconds...")
            if i == retries - 1:
                send_telegram(f"‚õîÔ∏è API Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô‡πÑ‡∏î‡πâ (Attempt {i+1}/{retries})\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {e}")
            time.sleep(15)
        except Exception as e:
            logger.error(f"‚ùå Unexpected error in get_current_position: {e}", exc_info=True)
            send_telegram(f"‚õîÔ∏èÔ∏è Unexpected Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô‡πÑ‡∏î‡πâ\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {e}")
            return None 
    logger.error(f"‚ùå Failed to fetch positions after {retries} attempts.")
    send_telegram(f"‚õîÔ∏è API Error: ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡πÇ‡∏û‡∏ã‡∏¥‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å {retries} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á.")
    return None

# ==============================================================================
# 9. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Indicators (INDICATOR CALCULATION FUNCTIONS)
# ==============================================================================

def calculate_ema(prices: list[float], period: int) -> float | None:
    if len(prices) < period:
        return None

    sma = sum(prices[:period]) / period
    ema = sma
    multiplier = 2 / (period + 1)

    for price in prices[period:]:
        ema = (price * multiplier) + (ema * (1 - multiplier))

    return ema

def check_ema_cross() -> str | None:
    global last_ema_position_status 
    
    try:
        retries = 3
        ohlcv = None
        for i in range(retries):
            logger.debug(f"üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• OHLCV ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö EMA ({i+1}/{retries})...")
            try:
                ohlcv = exchange.fetch_ohlcv(SYMBOL, TIMEFRAME, limit=500) 
                time.sleep(1) 
                break
            except (ccxt.NetworkError, ccxt.ExchangeError) as e:
                logger.warning(f"‚ö†Ô∏è Error fetching OHLCV (Attempt {i+1}/{retries}): {e}. Retrying in 15 seconds...")
                if i == retries - 1:
                    send_telegram(f"‚õîÔ∏è API Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á OHLCV ‡πÑ‡∏î‡πâ (Attempt {i+1}/{retries})\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {e}")
                time.sleep(15)
            except Exception as e:
                logger.error(f"‚ùå Unexpected error fetching OHLCV: {e}", exc_info=True)
                send_telegram(f"‚õîÔ∏è Unexpected Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á OHLCV ‡πÑ‡∏î‡πâ\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {e}")
                return None

        if not ohlcv:
            logger.error(f"‚ùå Failed to fetch OHLCV after {retries} attempts.")
            send_telegram(f"‚õîÔ∏è API Error: ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á OHLCV ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å {retries} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á.")
            return None

        if len(ohlcv) < 201: 
            logger.warning(f"‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• OHLCV ‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠. ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 201 ‡πÅ‡∏ó‡πà‡∏á ‡πÑ‡∏î‡πâ {len(ohlcv)}")
            send_telegram(f"‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• OHLCV ‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ ({len(ohlcv)} ‡πÅ‡∏ó‡πà‡∏á).")
            return None

        closes = [candle[4] for candle in ohlcv]

        ema50_current = calculate_ema(closes, 50)
        ema200_current = calculate_ema(closes, 200)

        logger.info(f"üí° EMA Values: Current EMA50={ema50_current:.2f}, EMA200={ema200_current:.2f}") 
        
        if None in [ema50_current, ema200_current]:
            logger.warning("‡∏Ñ‡πà‡∏≤ EMA ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏î‡πâ (‡πÄ‡∏õ‡πá‡∏ô None).")
            return None

        current_ema_position = None
        if ema50_current > ema200_current:
            current_ema_position = 'above'
        elif ema50_current < ema200_current:
            current_ema_position = 'below'
        
        if last_ema_position_status is None:
            if current_ema_position:
                last_ema_position_status = current_ema_position
                save_monthly_stats()
                logger.info(f"‚ÑπÔ∏è ‡∏ö‡∏≠‡∏ó‡πÄ‡∏û‡∏¥‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏±‡∏ô. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ EMA ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô: {current_ema_position.upper()}. ‡∏à‡∏∞‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ñ‡∏±‡∏î‡πÑ‡∏õ.")
            return None 

        cross_signal = None

        if last_ema_position_status == 'below' and current_ema_position == 'above' and \
           ema50_current > (ema200_current + CROSS_THRESHOLD_POINTS):
            cross_signal = 'long'
            logger.info(f"üöÄ Threshold Golden Cross: EMA50({ema50_current:.2f}) is {CROSS_THRESHOLD_POINTS} points above EMA200({ema200_current:.2f})")

        elif last_ema_position_status == 'above' and current_ema_position == 'below' and \
             ema50_current < (ema200_current - CROSS_THRESHOLD_POINTS):
            cross_signal = 'short'
            logger.info(f"üîª Threshold Death Cross: EMA50({ema50_current:.2f}) is {CROSS_THRESHOLD_POINTS} points below EMA200({ema200_current:.2f})")

        if cross_signal is not None:
            logger.info(f"‚ú® ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì EMA Cross ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö: {cross_signal.upper()}")
            if current_ema_position != last_ema_position_status:
                logger.info(f"‚ÑπÔ∏è EMA position changed from {last_ema_position_status.upper()} to {current_ema_position.upper()} during a cross signal. Updating last_ema_position_status.")
                last_ema_position_status = current_ema_position
                save_monthly_stats() 
        elif current_ema_position != last_ema_position_status: 
            logger.info(f"‚ÑπÔ∏è EMA position changed from {last_ema_position_status.upper()} to {current_ema_position.upper()}. Updating last_ema_position_status (no cross signal detected).")
            last_ema_position_status = current_ema_position
            save_monthly_stats() 
        else: 
            logger.info("üîé ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì EMA Cross ‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô.") 
            
        return cross_signal

    except Exception as e:
        logger.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì EMA: {e}", exc_info=True)
        send_telegram(f"‚õîÔ∏è Error: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì EMA ‡πÑ‡∏î‡πâ\n‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: {e}")
        return None

# ==============================================================================
# 10. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå
# ==============================================================================

def calculate_order_details(available_usdt: float, price: float) -> tuple[float, float]:
    """
    ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Contracts (‡∏™‡∏±‡∏ç‡∏ç‡∏≤) ‡πÅ‡∏•‡∏∞ Margin ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ö‡∏ô OKX.
    ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ limits ‡∏à‡∏≤‡∏Å market_info ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤.
    """
    try:
        # ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ limits ‡∏à‡∏≤‡∏Å market_info (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß)
        min_notional_exchange = float(market_info['limits']['cost'].get('min', '11.8')) 
        max_notional_exchange = float(market_info['limits']['cost'].get('max', str(sys.float_info.max))) 
        
        # *** IMPORTANT FIX ***
        # OKX BTC-USDT-SWAP contract size is DEFINITELY 0.0001 BTC per contract.
        # Your log showed 0.01, which is incorrect and caused the small order size.
        # Hardcode this value to ensure correctness, as market_info might sometimes be unreliable.
        contract_size_in_btc = 0.0001 # <--- ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
        logger.debug(f"DEBUG: Confirmed contract_size for {SYMBOL} is {contract_size_in_btc} BTC/contract.")

        # actual_contracts_step_size: ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏•‡∏î‡∏Ç‡∏≠‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏±‡∏ç‡∏ç‡∏≤ (‡πÄ‡∏ä‡πà‡∏ô 1.0 ‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏µ‡∏•‡∏∞ 1 ‡∏™‡∏±‡∏ç‡∏ç‡∏≤)
        # Your log shows 1.0, which is correct for contracts on OKX.
        actual_contracts_step_size = float(market_info['limits']['amount'].get('step', '1.0'))
        logger.debug(f"DEBUG: Actual Contract Step Size from market_info: {actual_contracts_step_size}")
        
        # min_exchange_contracts: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏ó‡∏µ‡πà Exchange ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï
        # Your log shows 0.01, which is incorrect if it means 0.01 CONTRACTS.
        # If it means 0.01 BTC, it's 100 contracts.
        # Based on OKX, min contracts for BTC-USDT-SWAP is 1.0.
        min_exchange_contracts = float(market_info['limits']['amount'].get('min', '1.0')) 
        
    except (TypeError, ValueError) as e:
        logger.critical(f"‚ùå Error parsing market limits for {SYMBOL}: {e}. Check API response structure. Exiting.", exc_info=True)
        send_telegram(f"‚õîÔ∏è Critical Error: Cannot parse market limits for {SYMBOL}.\nDetails: {e}")
        return (0, 0)

    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Margin Buffer ‡∏à‡∏≤‡∏Å‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡∏¢‡∏≠‡∏î Available USDT
    # ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏î‡πâ‡∏ß‡∏¢ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì buffer ‡∏ó‡∏µ‡πà‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ó‡∏∏‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å
    # ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ MARGIN_BUFFER_PERCENTAGE ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ
    actual_margin_buffer = max(available_usdt * MARGIN_BUFFER_PERCENTAGE, MIN_MARGIN_BUFFER_USDT) # <--- ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
    
    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Margin ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ (‡∏à‡∏≤‡∏Å Balance ‡∏ó‡∏µ‡πà‡∏°‡∏µ ‡πÅ‡∏•‡∏∞ Factor)
    target_initial_margin = (available_usdt - actual_margin_buffer) * TARGET_POSITION_SIZE_FACTOR

    if target_initial_margin <= 0:
        logger.warning(f"‚ùå Target initial margin ({target_initial_margin:.2f}) too low after buffer ({actual_margin_buffer} USDT).") # <--- ‡πÉ‡∏ä‡πâ actual_margin_buffer ‡πÉ‡∏ô log
        return (0, 0)

    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Notional Value ‡∏ó‡∏µ‡πà Margin ‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ
    target_notional_for_order = target_initial_margin * LEVERAGE

    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô BTC (Base Asset) ‡∏à‡∏≤‡∏Å Notional Value
    target_base_amount_btc_raw = target_notional_for_order / price

    # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Contracts ‡∏î‡∏¥‡∏ö‡πÜ (‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏©‡∏ï‡∏≤‡∏° step)
    contracts_raw = target_base_amount_btc_raw / contract_size_in_btc 
    
    # ‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏© contracts ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡∏ï‡∏≤‡∏° actual_contracts_step_size
    contracts_to_open = round(contracts_raw / actual_contracts_step_size) * actual_contracts_step_size
    
    # ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° precision ‡∏î‡πâ‡∏ß‡∏¢ f-string ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡πÉ‡∏´‡πâ CCXT ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á float inaccuracies
    contracts_to_open = float(f"{contracts_to_open:.8f}") # ‡∏õ‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 8 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á

    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÅ‡∏•‡∏∞‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á Contracts (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
    contracts_to_open = max(contracts_to_open, min_exchange_contracts)
    
    # ‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ô‡∏µ‡πâ ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Notional value ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏© Contracts
    # ‡∏Å‡∏±‡∏ö min_notional_exchange ‡∏î‡πâ‡∏ß‡∏¢
    actual_notional_after_precision = contracts_to_open * contract_size_in_btc * price
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Notional Value ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏Å‡∏±‡∏ö min_notional_exchange
    if actual_notional_after_precision < min_notional_exchange:
        # ‡∏´‡∏≤‡∏Å Notional ‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡∏´‡∏•‡∏±‡∏á‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏© contracts ‡πÅ‡∏•‡πâ‡∏ß‡∏¢‡∏±‡∏á‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏Ç‡∏≠‡∏á Notional
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Contracts ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö min_notional_exchange
        contracts_from_min_notional = min_notional_exchange / (contract_size_in_btc * price)
        contracts_from_min_notional = round(contracts_from_min_notional / actual_contracts_step_size) * actual_contracts_step_size
        contracts_from_min_notional = float(f"{contracts_from_min_notional:.8f}")
        
        # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å contracts_to_open ‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏à‡∏≤‡∏Å min_notional
        contracts_to_open = max(contracts_to_open, contracts_from_min_notional)
        actual_notional_after_precision = contracts_to_open * contract_size_in_btc * price # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Notional ‡∏ï‡∏≤‡∏° contracts ‡πÉ‡∏´‡∏°‡πà

    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Margin ‡∏ó‡∏µ‡πà‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å Contracts ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î
    required_margin = actual_notional_after_precision / LEVERAGE

    if contracts_to_open == 0:
        logger.warning(f"‚ö†Ô∏è Calculated contracts to open is 0 after all adjustments. (Target Notional: {target_notional_for_order:.2f} USDT).")
        return (0, 0)
        
    if available_usdt < required_margin + actual_margin_buffer: # <--- ‡πÉ‡∏ä‡πâ actual_margin_buffer ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
        logger.error(f"‚ùå Margin not sufficient. Available: {available_usdt:.2f}, Required: {required_margin:.2f} + {actual_margin_buffer} (Buffer) = {required_margin + actual_margin_buffer:.2f} USDT.") # <--- ‡πÉ‡∏ä‡πâ actual_margin_buffer ‡πÉ‡∏ô log
        return (0, 0)
    
    logger.debug(f"üí° DEBUG (calculate_order_details): Available USDT: {available_usdt:.2f}")
    logger.debug(f"üí° DEBUG (calculate_order_details): Target Initial Margin: {target_initial_margin:.2f}")
    logger.debug(f"üí° DEBUG (calculate_order_details): Target Notional: {target_notional_for_order:.2f} USDT")
    # ‡πÄ‡∏û‡∏¥‡πà‡∏° logging ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Actual Margin Buffer
    logger.debug(f"üí° DEBUG (calculate_order_details): Actual Margin Buffer: {actual_margin_buffer:.2f} USDT")
    # ... (‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏Ç‡∏≠‡∏á logging ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ...
    logger.debug(f"üí° DEBUG (calculate_order_details): Contract Size (BTC/Contract): {contract_size_in_btc:.8f}")
    logger.debug(f"üí° DEBUG (calculate_order_details): Raw Contracts: {contracts_raw:.8f}") 
    logger.debug(f"üí° DEBUG (calculate_order_details): Actual Contract Step Size: {actual_contracts_step_size}")
    logger.debug(f"üí° DEBUG (calculate_order_details): Contracts to Open (final calculated): {contracts_to_open:.8f}") 
    logger.debug(f"üí° DEBUG (calculate_order_details): Actual Notional (after precision): {actual_notional_after_precision:.2f} USDT")
    logger.debug(f"üí° DEBUG (calculate_order_details): Calculated Required Margin: {required_margin:.2f} USDT")
    logger.debug(f"üí° DEBUG (calculate_order_details): Min Notional Exchange: {min_notional_exchange:.2f}")
    logger.debug(f"üí° DEBUG (calculate_order_details): Min Contracts Exchange: {min_exchange_contracts:.8f}")

    return (contracts_to_open, required_margin) # <-- ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Contracts, Margin)

# ... (‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏Ç‡∏≠‡∏á‡πÇ‡∏Ñ‡πâ‡∏î open_market_order, set_tpsl_for_position, monitor_position ‡∏Ø‡∏•‡∏Ø ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ...
